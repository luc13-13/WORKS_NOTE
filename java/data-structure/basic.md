# Java 基本数据类型

基本概念：<font color=Tomato>存储空间以'位(bite)'为单位，1 byte = 8 bite，1 kb = 1024 byte</font>。可以将 1 bite视为一个单元格，其中存储0或1

|类型|-|占用存储空间|数据范围|
|:---:|:---:|:---:|:---:|
|整型|byte|1字节|-128 ~ 127|
|-|short|2字节|-2^15^ ~ 2^15^-1|
|-|int|4字节|-2^31^ ~ 2^31^-1|
|-|long|8字节|-2^63^ ~ 2^63^-1|
|浮点型|float|4字节|-2^128^ ~ 2^127^|
|-|double|8字节|-2^|
|字符型|char|取决于编码格式||
|布尔型|boolean|取决于虚拟机||
---

## 整型在计算机中的存储和运算

java中整数 int 占 4 字节的存储空间，理论上 32 位可以2^32^个正整数，为了表示负数，int 的第一位用来标记数字正负，称为<font color=Tomato>符号位</font>，0表示正数，1表示负数，剩余的为<font color=Tomato>数值位</font>以整数 int i = 17 为例，
<table>
<caption>int i = 17 的存储方式</caption>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>1</td>
<td>0</td><td>0</td><td>0</td><td>1</td>
</tr>
</table>

<table>
<caption>int i = 5 的存储方式</caption>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>1</td><td>0</td><td>1</td>
</tr>
</table>

在正整数进行加减运算时，相应二进制位上的数字相加，逢二进一即可，例如计算 5+17 时，二进制运算结果为

<table>
<caption>5 + 17 的结果</caption>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>1</td>
<td>0</td><td>1</td><td>1</td><td>0</td>
</tr>
</table>

5 + 17 = 2^4^ + 0 + 2^2^ + 2 + 0 = 22

但是如果考虑到负数的运算时，二进制位直接相加则无法得到正确的结果，例如 17 + (-5)
<table>
<caption>int i = -5</caption>
<tr>
<td>1</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>1</td><td>0</td><td>1</td>
</tr>
</table>

<table>
<caption>二进制位相加得到的 17 + (-5)</caption>
<tr>
<td>1</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td>
</tr>
<tr>
<td>0</td><td>0</td><td>0</td><td>1</td>
<td>0</td><td>1</td><td>1</td><td>0</td>
</tr>
</table>

直接相加后所表示的数值为 -1 * (2^4^  + 0 + 2^2^ + 2 + 0) = -22，结果错误。<font color=Tomato>因此，直接对整数的二进制进行运算是不正确的，不可以直接用原码存储数字</font>，这里便引入了反码和补码的概念。
整数的二进制表示形式称之为原码，例如上面对 17 和 5 的表示；正数反码为其本身，负数反码则对其原码的数值位逐位取反；正数的补码为其本身，负数的补码为其反码+1。如果用两个数的反码来进行运算，同样以 17 和 -5 为例(省略前24位数值位，即下面第一位为符号位)
|十进制|原码|反码|
|:---:|---:|---:|
|17|0 00010001|0 00010001|
|-5|1 00000101|1 11111010|
||对反码运算结果|0 0 00001011 |
|12|0 0 00001011 |反码转为原码|

以-17 + 5 为例
|十进制|原码|反码|
|:---:|---:|---:|
|-17|1 00010001|1 11101110|
|5|0 00000101|0 00000101|
||对反码运算结果|1 11110011 |
|-12|1 0 00001100 |反码转为原码|

但是如果计算 17 + (-17)
|十进制|原码|反码|
|:---:|---:|---:|
|17|0 00010001|0 00010001|
|-17|1 00010001|1 11101110|
||对反码运算结果|1 11111111 |
|-0|1 0 00000000 |反码转为原码|

这里出现了 -0 的情况，<font color=Tomato>同一个数 0 在二进制中有两种不同表示方式，会存在歧义</font>，因此反码的存储方式被抛弃，转而采用补码。上面提到，正数的补码为其本身，负数补码为其反码+1，采用补码计算 17 + (-17)时
|十进制|原码|反码|补码|
|:---:|---:|---:|---:|
|17|0 00010001|0 00010001|0 00010001|
|-17|1 00010001|1 11101110|1 11101111|
|||对补码运算结果——>|0 00000000|
|0|0 0 00000000|<——补码转为原码||


### 总结
（1）整数的存储内容包括两部分，第一位的符号位和剩余的数值位
（2）原码 = 数字的二进制形式； 正数的反码为其本身，负数的反码 = 对原码的数值位逐个取反； 整数的补码为其本身，负数的补码 = 反码 + 1
（3）采用反码的方式对整数进行存储和运算
（4）负数的原码 = 补码 - 1 再取反

### <font color=Tomato>为什么是 - 2^31^ ~ 2^31^-1 ？</font>

先考虑占1字节的 byte 类型，其最小值为为 -2^7^，最大值为 2^7^-1。对于正数很好理解，0111 1111为byte能表示的最大正正数，对应的十进制数字为 2^6^ + 2^5^ + 2^4^ + 2^3^ + 2^2^ + 2^1^ + 2^0^, 根据等比数列求和公式
$$\frac{a_1(1-q^n)} {1-q}$$
取q=2, n=7, a~1~=1, 得到 0111 1111表示 2^8-1^ - 1 = 127。

但是如果考虑到负数，首先看 -1 + -127的计算过程
|十进制|原码|反码|补码|
|:---:|---:|---:|---:|
|-1|1000 0001|1111 1110|1111 1111|
|-127|1111 1111|1000 0000|1000 0001|
|||对补码运算结果——>|1000 0000|
|-128||||


可以看到出现了1000 0000这种表达方式，对应着-0，但计算机中不考虑-0这个数字，因此将1000 0000规定为 -2^7^，同时 1000 0000不具备反码和原码，直接对应十进制数字。因此，整型数据的负数范围总是比其整数范围多一个，原因在于-0被负数最小值取代。

---

## 浮点型

浮点型的存储结构包括三部分：符号位、指数为和尾数部分。float占用的存储空间为4字节，即 32 bite

<table>
<th>1位</th><th colspan=8>8位指数位</th><th colspan=23>23位尾数位</th>
</table>

符号位：0表示整数，1表示负数；
指数位：同样分正负，第一位为指数为的符号位，8位可以表示的整数范围是-128~127
尾数为：
